<!--  Footer  -->


<!-- Import scripts -->
<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

<script>
    $(document).ready(function() {
        setTimeout(function() {
            $(".alert-success").alert('close');
            $(".alert-danger").alert('close');
        }, 2000);
    });

    var previousfilterbuttonId = 'undefined';
    var filter = 'undefined'

    $('.js-filter-slides-button').on('click', function(){
        // Unfliter previously possible filters applied to the carousel
        $('.center').slick('slickUnfilter');

        // We assign this button id as the next previous filter button id
        let filterbuttonId = $(this).attr('id');
        let button = document.getElementById(previousfilterbuttonId);

        if (filterbuttonId === previousfilterbuttonId && filter !== 'undefined') {
            // We are clicking the same button to un-filter: we reset the button's style and blur to unfocus
            // We have unfiltered the carousel by default
            // We assign the undefined as the applied filter to the variable
            filter = 'undefined';
            button.classList.remove('active');
            $(this).blur();
        } else {
            // Obtain the filter we want to apply through the data-filter
            filter = $(this).data('filter');
            
            // List of available filters
            if(filter === 'anime'){
                // Filter animes
                $('.center').slick('slickFilter', '.anime');
            } else if (filter === 'classic-rpg') {
                // Filter classic-rpg games
                $('.center').slick('slickFilter', '.classic-rpg');
            } else if (filter === 'deck-builder') {
                // Filter deck-builder games
                $('.center').slick('slickFilter', '.deck-builder');
            } else if (filter === 'documentary') {
                // Filter documentaries
                $('.center').slick('slickFilter', '.documentary');
            } else if (filter === 'emotional-damage') {
                // Filter emotional damage shows
                $('.center').slick('slickFilter', '.emotional-damage');
            } else if (filter === 'indie') {
                // Filter indie games
                $('.center').slick('slickFilter', '.indie');
            } else if (filter === 'metroidvania') {
                // Filter metroidvania games
                $('.center').slick('slickFilter', '.metroidvania');
            } else if (filter === 'rogue-like') {
                // Filter rogue-like games
                $('.center').slick('slickFilter', '.rogue-like');
            } else if (filter === 'souls-like') {
                // Filter souls-like games
                $('.center').slick('slickFilter', '.souls-like');
            } else if (filter === 'open-world') {
                // Filter open-world games
                $('.center').slick('slickFilter', '.open-world');
            } else if (filter === 'clear') {
                // We have unfiltered the carousel by default
                // We assign the undefined as the applied filter to the variable
                filter = 'undefined';
            }

            if (filterbuttonId !== previousfilterbuttonId && previousfilterbuttonId !== 'undefined') {
                // We remove the style ('active' class) of the button of the previous applied filter
                button.classList.remove('active');
            }
        }
        
        previousfilterbuttonId = filterbuttonId;
    });

    function startCarousel(){
        $('.center').slick({
            centerMode: true,
            centerPadding: '5px', // dots: true, tengo que pensar m√°s sobre esto
            slidesToShow: 3,
            swipeToSlide: true, // custom feat.
            responsive: [
                {
                    breakpoint: 4000,
                    settings: {
                    arrows: false,
                    centerMode: true,
                    centerPadding: '5px',
                    slidesToShow: 7
                    }
                },
                {
                    breakpoint: 1500,
                    settings: {
                    arrows: false,
                    centerMode: true,
                    centerPadding: '5px',
                    slidesToShow: 3
                    }
                },
                {
                    breakpoint: 1080,
                    settings: {
                    arrows: true,
                    centerMode: true,
                    centerPadding: '5px',
                    slidesToShow: 3
                    }
                },
                {
                    breakpoint: 760,
                    settings: {
                    arrows: true,
                    centerMode: true,
                    centerPadding: '5px',
                    slidesToShow: 1
                    }
                }
            ]
        });
    }

    function httpGetAsync(theUrl, callback)
    {
        var xmlHttp = new XMLHttpRequest();
        xmlHttp.onreadystatechange = function() { 
            if (xmlHttp.readyState == 4 && xmlHttp.status == 200)
                callback(xmlHttp.responseText);
        }
        xmlHttp.open("GET", theUrl, true); // true for asynchronous 
        xmlHttp.send(null);
    }
</script>